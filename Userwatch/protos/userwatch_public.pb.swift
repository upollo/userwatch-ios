// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: userwatch_public.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Uwproto_EventType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case login // = 1
  case register // = 2
  case attemptPurchase // = 3
  case completePurchase // = 4
  case attemptRedeemOffer // = 5
  case redeemedOffer // = 6
  case verifyDevice // = 7
  case reportDevice // = 8
  case addTeamMember // = 9
  case removeTeamMember // = 10
  case addPaymentMethod // = 11
  case attemptDeleteAccount // = 12
  case customerDefined // = 13
  case startSubscription // = 14
  case endSubscription // = 15
  case heartbeat // = 16
  case pageVisit // = 17
  case loginSuccess // = 18
  case registerSuccess // = 19
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .login
    case 2: self = .register
    case 3: self = .attemptPurchase
    case 4: self = .completePurchase
    case 5: self = .attemptRedeemOffer
    case 6: self = .redeemedOffer
    case 7: self = .verifyDevice
    case 8: self = .reportDevice
    case 9: self = .addTeamMember
    case 10: self = .removeTeamMember
    case 11: self = .addPaymentMethod
    case 12: self = .attemptDeleteAccount
    case 13: self = .customerDefined
    case 14: self = .startSubscription
    case 15: self = .endSubscription
    case 16: self = .heartbeat
    case 17: self = .pageVisit
    case 18: self = .loginSuccess
    case 19: self = .registerSuccess
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .login: return 1
    case .register: return 2
    case .attemptPurchase: return 3
    case .completePurchase: return 4
    case .attemptRedeemOffer: return 5
    case .redeemedOffer: return 6
    case .verifyDevice: return 7
    case .reportDevice: return 8
    case .addTeamMember: return 9
    case .removeTeamMember: return 10
    case .addPaymentMethod: return 11
    case .attemptDeleteAccount: return 12
    case .customerDefined: return 13
    case .startSubscription: return 14
    case .endSubscription: return 15
    case .heartbeat: return 16
    case .pageVisit: return 17
    case .loginSuccess: return 18
    case .registerSuccess: return 19
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Uwproto_EventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Uwproto_EventType] = [
    .unspecified,
    .login,
    .register,
    .attemptPurchase,
    .completePurchase,
    .attemptRedeemOffer,
    .redeemedOffer,
    .verifyDevice,
    .reportDevice,
    .addTeamMember,
    .removeTeamMember,
    .addPaymentMethod,
    .attemptDeleteAccount,
    .customerDefined,
    .startSubscription,
    .endSubscription,
    .heartbeat,
    .pageVisit,
    .loginSuccess,
    .registerSuccess,
  ]
}

#endif  // swift(>=4.2)

public enum Uwproto_Outcome: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case deny // = 1
  case challenge // = 2
  case permit // = 3
  case offer // = 4
  case log // = 5
  case customerDefined // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .deny
    case 2: self = .challenge
    case 3: self = .permit
    case 4: self = .offer
    case 5: self = .log
    case 6: self = .customerDefined
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .deny: return 1
    case .challenge: return 2
    case .permit: return 3
    case .offer: return 4
    case .log: return 5
    case .customerDefined: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Uwproto_Outcome: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Uwproto_Outcome] = [
    .unspecified,
    .deny,
    .challenge,
    .permit,
    .offer,
    .log,
    .customerDefined,
  ]
}

#endif  // swift(>=4.2)

public enum Uwproto_FlagType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case accountSharing // = 1
  case accountSharingSameHousehold // = 2
  case suspectedAccountCompromise // = 3
  case credentialStuffing // = 4
  case repeatedRedemption // = 5
  case suspectedFraud // = 6
  case repeatedSignup // = 7
  case suspectedBot // = 8
  case rateLimitedIp // = 9
  case rateLimitedDevice // = 10
  case blacklistedIp // = 11

  /// DEPRECATED
  case blacklistedDevice // = 12
  case accountCompromiseNewLocation // = 13
  case accountCompromiseNewDevice // = 14
  case repeatedAction // = 15
  case disposableEmail // = 16
  case usingVpn // = 17
  case usingTor // = 18
  case deviceBlockedGlobally // = 19
  case deviceBlockedForThisUser // = 20
  case invalidEmail // = 21
  case invalidPhoneNumber // = 23
  case invalidPhoneType // = 22
  case multipleAccounts // = 24
  case alreadyUsedEmail // = 25
  case alreadyUsedPhone // = 26
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .accountSharing
    case 2: self = .accountSharingSameHousehold
    case 3: self = .suspectedAccountCompromise
    case 4: self = .credentialStuffing
    case 5: self = .repeatedRedemption
    case 6: self = .suspectedFraud
    case 7: self = .repeatedSignup
    case 8: self = .suspectedBot
    case 9: self = .rateLimitedIp
    case 10: self = .rateLimitedDevice
    case 11: self = .blacklistedIp
    case 12: self = .blacklistedDevice
    case 13: self = .accountCompromiseNewLocation
    case 14: self = .accountCompromiseNewDevice
    case 15: self = .repeatedAction
    case 16: self = .disposableEmail
    case 17: self = .usingVpn
    case 18: self = .usingTor
    case 19: self = .deviceBlockedGlobally
    case 20: self = .deviceBlockedForThisUser
    case 21: self = .invalidEmail
    case 22: self = .invalidPhoneType
    case 23: self = .invalidPhoneNumber
    case 24: self = .multipleAccounts
    case 25: self = .alreadyUsedEmail
    case 26: self = .alreadyUsedPhone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .accountSharing: return 1
    case .accountSharingSameHousehold: return 2
    case .suspectedAccountCompromise: return 3
    case .credentialStuffing: return 4
    case .repeatedRedemption: return 5
    case .suspectedFraud: return 6
    case .repeatedSignup: return 7
    case .suspectedBot: return 8
    case .rateLimitedIp: return 9
    case .rateLimitedDevice: return 10
    case .blacklistedIp: return 11
    case .blacklistedDevice: return 12
    case .accountCompromiseNewLocation: return 13
    case .accountCompromiseNewDevice: return 14
    case .repeatedAction: return 15
    case .disposableEmail: return 16
    case .usingVpn: return 17
    case .usingTor: return 18
    case .deviceBlockedGlobally: return 19
    case .deviceBlockedForThisUser: return 20
    case .invalidEmail: return 21
    case .invalidPhoneType: return 22
    case .invalidPhoneNumber: return 23
    case .multipleAccounts: return 24
    case .alreadyUsedEmail: return 25
    case .alreadyUsedPhone: return 26
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Uwproto_FlagType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Uwproto_FlagType] = [
    .unspecified,
    .accountSharing,
    .accountSharingSameHousehold,
    .suspectedAccountCompromise,
    .credentialStuffing,
    .repeatedRedemption,
    .suspectedFraud,
    .repeatedSignup,
    .suspectedBot,
    .rateLimitedIp,
    .rateLimitedDevice,
    .blacklistedIp,
    .blacklistedDevice,
    .accountCompromiseNewLocation,
    .accountCompromiseNewDevice,
    .repeatedAction,
    .disposableEmail,
    .usingVpn,
    .usingTor,
    .deviceBlockedGlobally,
    .deviceBlockedForThisUser,
    .invalidEmail,
    .invalidPhoneNumber,
    .invalidPhoneType,
    .multipleAccounts,
    .alreadyUsedEmail,
    .alreadyUsedPhone,
  ]
}

#endif  // swift(>=4.2)

public enum Uwproto_DeviceClass: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case desktop // = 0
  case mobile // = 1
  case tablet // = 2
  case goodbot // = 3
  case badbot // = 4
  case unknown // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .desktop
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .desktop
    case 1: self = .mobile
    case 2: self = .tablet
    case 3: self = .goodbot
    case 4: self = .badbot
    case 5: self = .unknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .desktop: return 0
    case .mobile: return 1
    case .tablet: return 2
    case .goodbot: return 3
    case .badbot: return 4
    case .unknown: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Uwproto_DeviceClass: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Uwproto_DeviceClass] = [
    .desktop,
    .mobile,
    .tablet,
    .goodbot,
    .badbot,
    .unknown,
  ]
}

#endif  // swift(>=4.2)

public enum Uwproto_ChallengeType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case webauthn // = 1
  case sms // = 2
  case email // = 3
  case banksy // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .webauthn
    case 2: self = .sms
    case 3: self = .email
    case 4: self = .banksy
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .webauthn: return 1
    case .sms: return 2
    case .email: return 3
    case .banksy: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Uwproto_ChallengeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Uwproto_ChallengeType] = [
    .unspecified,
    .webauthn,
    .sms,
    .email,
    .banksy,
  ]
}

#endif  // swift(>=4.2)

public struct Uwproto_AnalysisResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Recommended action based on the Userwatch analysis.
  public var action: Uwproto_Outcome {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  /// All flags the Userwatch analysis identified.
  /// Note any flags with an ignored_until value after the present should
  /// generally be treated as if they were not present. Those ignored flags are
  /// already excluded from factoring into the action Outcome above.
  public var flags: [Uwproto_Flag] {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  /// True if Userwatch detects a VPN is being used.
  /// Deprecated: This is available as in flags as type USING_VPN
  public var isUsingVpn: Bool {
    get {return _storage._isUsingVpn}
    set {_uniqueStorage()._isUsingVpn = newValue}
  }

  /// True if Userwatch detects TOR is being used.
  /// Deprecated: This is available in flags as type USING_TOR
  public var isUsingTor: Bool {
    get {return _storage._isUsingTor}
    set {_uniqueStorage()._isUsingTor = newValue}
  }

  /// Information Userwatch discerned about the user.
  public var userInfo: Uwproto_UserInfo {
    get {return _storage._userInfo ?? Uwproto_UserInfo()}
    set {_uniqueStorage()._userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return _storage._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {_uniqueStorage()._userInfo = nil}

  /// Information Userwatch discerned about the device.
  public var deviceInfo: Uwproto_DeviceInfo {
    get {return _storage._deviceInfo ?? Uwproto_DeviceInfo()}
    set {_uniqueStorage()._deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  public var hasDeviceInfo: Bool {return _storage._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceInfo() {_uniqueStorage()._deviceInfo = nil}

  /// Geographic information discerned by Userwatch.
  public var geoInfo: Uwproto_GeoInfo {
    get {return _storage._geoInfo ?? Uwproto_GeoInfo()}
    set {_uniqueStorage()._geoInfo = newValue}
  }
  /// Returns true if `geoInfo` has been explicitly set.
  public var hasGeoInfo: Bool {return _storage._geoInfo != nil}
  /// Clears the value of `geoInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGeoInfo() {_uniqueStorage()._geoInfo = nil}

  /// TODO: Is this always set, or only for certain outcomes?
  /// TODO: Does this represent the set of challenges Userwatch currently
  ///       supports, or specifically the ones which are considered sufficient
  ///       to deal with the current flags?
  public var supportedChallenges: [Uwproto_ChallengeType] {
    get {return _storage._supportedChallenges}
    set {_uniqueStorage()._supportedChallenges = newValue}
  }

  /// Unique identifier of the request which resulted in this analysis.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Event type which resulted in this analysis being done.
  public var eventType: Uwproto_EventType {
    get {return _storage._eventType}
    set {_uniqueStorage()._eventType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Uwproto_Flag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Uwproto_FlagType = .unspecified

  public var firstFlagged: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _firstFlagged ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_firstFlagged = newValue}
  }
  /// Returns true if `firstFlagged` has been explicitly set.
  public var hasFirstFlagged: Bool {return self._firstFlagged != nil}
  /// Clears the value of `firstFlagged`. Subsequent reads from it will return its default value.
  public mutating func clearFirstFlagged() {self._firstFlagged = nil}

  public var mostRecentlyFlagged: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _mostRecentlyFlagged ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_mostRecentlyFlagged = newValue}
  }
  /// Returns true if `mostRecentlyFlagged` has been explicitly set.
  public var hasMostRecentlyFlagged: Bool {return self._mostRecentlyFlagged != nil}
  /// Clears the value of `mostRecentlyFlagged`. Subsequent reads from it will return its default value.
  public mutating func clearMostRecentlyFlagged() {self._mostRecentlyFlagged = nil}

  /// A nil ignored_until value, or a non-nil value before the present, means
  /// this flag is set and should be treated accordingly.
  /// A non-nil ignored_until value which is after the present indicates this
  /// flag is set, but should be ignored â€” i.e. treated as if not flagged.
  /// The max time further indicates that the flag should be ignored forever.
  public var ignoredUntil: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _ignoredUntil ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_ignoredUntil = newValue}
  }
  /// Returns true if `ignoredUntil` has been explicitly set.
  public var hasIgnoredUntil: Bool {return self._ignoredUntil != nil}
  /// Clears the value of `ignoredUntil`. Subsequent reads from it will return its default value.
  public mutating func clearIgnoredUntil() {self._ignoredUntil = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _firstFlagged: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _mostRecentlyFlagged: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _ignoredUntil: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Uwproto_UserInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var userEmail: String = String()

  public var userPhone: String = String()

  public var userName: String = String()

  public var userImage: String = String()

  public var customerSuppliedValues: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Uwproto_DeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var deviceID: String = String()

  public var os: String = String()

  public var deviceClass: Uwproto_DeviceClass = .desktop

  public var deviceName: String = String()

  public var userAgent: String = String()

  public var browser: String = String()

  public var lastUsed: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastUsed ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastUsed = newValue}
  }
  /// Returns true if `lastUsed` has been explicitly set.
  public var hasLastUsed: Bool {return self._lastUsed != nil}
  /// Clears the value of `lastUsed`. Subsequent reads from it will return its default value.
  public mutating func clearLastUsed() {self._lastUsed = nil}

  public var blockedGlobally: Bool = false

  /// Will always be false if request is unrelated to a single user
  public var blockedForThisUser: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastUsed: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Uwproto_GeoInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var geoIpLatlng: Uwproto_LatLng {
    get {return _geoIpLatlng ?? Uwproto_LatLng()}
    set {_geoIpLatlng = newValue}
  }
  /// Returns true if `geoIpLatlng` has been explicitly set.
  public var hasGeoIpLatlng: Bool {return self._geoIpLatlng != nil}
  /// Clears the value of `geoIpLatlng`. Subsequent reads from it will return its default value.
  public mutating func clearGeoIpLatlng() {self._geoIpLatlng = nil}

  public var geoIpCity: String = String()

  public var geoIpSubregion: String = String()

  public var geoIpRegion: String = String()

  public var lastHere: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastHere ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastHere = newValue}
  }
  /// Returns true if `lastHere` has been explicitly set.
  public var hasLastHere: Bool {return self._lastHere != nil}
  /// Clears the value of `lastHere`. Subsequent reads from it will return its default value.
  public mutating func clearLastHere() {self._lastHere = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _geoIpLatlng: Uwproto_LatLng? = nil
  fileprivate var _lastHere: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Uwproto_LatLng {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The latitude in degrees. It must be in the range [-90.0, +90.0].
  public var latitude: Double = 0

  /// The longitude in degrees. It must be in the range [-180.0, +180.0].
  public var longitude: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Uwproto_EventType: @unchecked Sendable {}
extension Uwproto_Outcome: @unchecked Sendable {}
extension Uwproto_FlagType: @unchecked Sendable {}
extension Uwproto_DeviceClass: @unchecked Sendable {}
extension Uwproto_ChallengeType: @unchecked Sendable {}
extension Uwproto_AnalysisResponse: @unchecked Sendable {}
extension Uwproto_Flag: @unchecked Sendable {}
extension Uwproto_UserInfo: @unchecked Sendable {}
extension Uwproto_DeviceInfo: @unchecked Sendable {}
extension Uwproto_GeoInfo: @unchecked Sendable {}
extension Uwproto_LatLng: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "uwproto"

extension Uwproto_EventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVENT_TYPE_UNSPECIFIED"),
    1: .same(proto: "EVENT_TYPE_LOGIN"),
    2: .same(proto: "EVENT_TYPE_REGISTER"),
    3: .same(proto: "EVENT_TYPE_ATTEMPT_PURCHASE"),
    4: .same(proto: "EVENT_TYPE_COMPLETE_PURCHASE"),
    5: .same(proto: "EVENT_TYPE_ATTEMPT_REDEEM_OFFER"),
    6: .same(proto: "EVENT_TYPE_REDEEMED_OFFER"),
    7: .same(proto: "EVENT_TYPE_VERIFY_DEVICE"),
    8: .same(proto: "EVENT_TYPE_REPORT_DEVICE"),
    9: .same(proto: "EVENT_TYPE_ADD_TEAM_MEMBER"),
    10: .same(proto: "EVENT_TYPE_REMOVE_TEAM_MEMBER"),
    11: .same(proto: "EVENT_TYPE_ADD_PAYMENT_METHOD"),
    12: .same(proto: "EVENT_TYPE_ATTEMPT_DELETE_ACCOUNT"),
    13: .same(proto: "EVENT_TYPE_CUSTOMER_DEFINED"),
    14: .same(proto: "EVENT_TYPE_START_SUBSCRIPTION"),
    15: .same(proto: "EVENT_TYPE_END_SUBSCRIPTION"),
    16: .same(proto: "EVENT_TYPE_HEARTBEAT"),
    17: .same(proto: "EVENT_TYPE_PAGE_VISIT"),
    18: .same(proto: "EVENT_TYPE_LOGIN_SUCCESS"),
    19: .same(proto: "EVENT_TYPE_REGISTER_SUCCESS"),
  ]
}

extension Uwproto_Outcome: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OUTCOME_UNSPECIFIED"),
    1: .same(proto: "OUTCOME_DENY"),
    2: .same(proto: "OUTCOME_CHALLENGE"),
    3: .same(proto: "OUTCOME_PERMIT"),
    4: .same(proto: "OUTCOME_OFFER"),
    5: .same(proto: "OUTCOME_LOG"),
    6: .same(proto: "OUTCOME_CUSTOMER_DEFINED"),
  ]
}

extension Uwproto_FlagType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FLAG_TYPE_UNSPECIFIED"),
    1: .same(proto: "FLAG_TYPE_ACCOUNT_SHARING"),
    2: .same(proto: "FLAG_TYPE_ACCOUNT_SHARING_SAME_HOUSEHOLD"),
    3: .same(proto: "FLAG_TYPE_SUSPECTED_ACCOUNT_COMPROMISE"),
    4: .same(proto: "FLAG_TYPE_CREDENTIAL_STUFFING"),
    5: .same(proto: "FLAG_TYPE_REPEATED_REDEMPTION"),
    6: .same(proto: "FLAG_TYPE_SUSPECTED_FRAUD"),
    7: .same(proto: "FLAG_TYPE_REPEATED_SIGNUP"),
    8: .same(proto: "FLAG_TYPE_SUSPECTED_BOT"),
    9: .same(proto: "FLAG_TYPE_RATE_LIMITED_IP"),
    10: .same(proto: "FLAG_TYPE_RATE_LIMITED_DEVICE"),
    11: .same(proto: "FLAG_TYPE_BLACKLISTED_IP"),
    12: .same(proto: "FLAG_TYPE_BLACKLISTED_DEVICE"),
    13: .same(proto: "FLAG_TYPE_ACCOUNT_COMPROMISE_NEW_LOCATION"),
    14: .same(proto: "FLAG_TYPE_ACCOUNT_COMPROMISE_NEW_DEVICE"),
    15: .same(proto: "FLAG_TYPE_REPEATED_ACTION"),
    16: .same(proto: "FLAG_TYPE_DISPOSABLE_EMAIL"),
    17: .same(proto: "FLAG_TYPE_USING_VPN"),
    18: .same(proto: "FLAG_TYPE_USING_TOR"),
    19: .same(proto: "FLAG_TYPE_DEVICE_BLOCKED_GLOBALLY"),
    20: .same(proto: "FLAG_TYPE_DEVICE_BLOCKED_FOR_THIS_USER"),
    21: .same(proto: "FLAG_TYPE_INVALID_EMAIL"),
    22: .same(proto: "FLAG_TYPE_INVALID_PHONE_TYPE"),
    23: .same(proto: "FLAG_TYPE_INVALID_PHONE_NUMBER"),
    24: .same(proto: "FLAG_TYPE_MULTIPLE_ACCOUNTS"),
    25: .same(proto: "FLAG_TYPE_ALREADY_USED_EMAIL"),
    26: .same(proto: "FLAG_TYPE_ALREADY_USED_PHONE"),
  ]
}

extension Uwproto_DeviceClass: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_CLASS_DESKTOP"),
    1: .same(proto: "DEVICE_CLASS_MOBILE"),
    2: .same(proto: "DEVICE_CLASS_TABLET"),
    3: .same(proto: "DEVICE_CLASS_GOODBOT"),
    4: .same(proto: "DEVICE_CLASS_BADBOT"),
    5: .same(proto: "DEVICE_CLASS_UNKNOWN"),
  ]
}

extension Uwproto_ChallengeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHALLENGE_TYPE_UNSPECIFIED"),
    1: .same(proto: "CHALLENGE_TYPE_WEBAUTHN"),
    2: .same(proto: "CHALLENGE_TYPE_SMS"),
    3: .same(proto: "CHALLENGE_TYPE_EMAIL"),
    4: .same(proto: "CHALLENGE_TYPE_BANKSY"),
  ]
}

extension Uwproto_AnalysisResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnalysisResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    6: .same(proto: "flags"),
    3: .standard(proto: "is_using_vpn"),
    4: .standard(proto: "is_using_tor"),
    7: .standard(proto: "user_info"),
    8: .standard(proto: "device_info"),
    9: .standard(proto: "geo_info"),
    11: .standard(proto: "supported_challenges"),
    10: .standard(proto: "request_id"),
    12: .standard(proto: "event_type"),
  ]

  fileprivate class _StorageClass {
    var _action: Uwproto_Outcome = .unspecified
    var _flags: [Uwproto_Flag] = []
    var _isUsingVpn: Bool = false
    var _isUsingTor: Bool = false
    var _userInfo: Uwproto_UserInfo? = nil
    var _deviceInfo: Uwproto_DeviceInfo? = nil
    var _geoInfo: Uwproto_GeoInfo? = nil
    var _supportedChallenges: [Uwproto_ChallengeType] = []
    var _requestID: String = String()
    var _eventType: Uwproto_EventType = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
      _flags = source._flags
      _isUsingVpn = source._isUsingVpn
      _isUsingTor = source._isUsingTor
      _userInfo = source._userInfo
      _deviceInfo = source._deviceInfo
      _geoInfo = source._geoInfo
      _supportedChallenges = source._supportedChallenges
      _requestID = source._requestID
      _eventType = source._eventType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._isUsingVpn) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._isUsingTor) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._flags) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._userInfo) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._deviceInfo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._geoInfo) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 11: try { try decoder.decodeRepeatedEnumField(value: &_storage._supportedChallenges) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._eventType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._action != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 1)
      }
      if _storage._isUsingVpn != false {
        try visitor.visitSingularBoolField(value: _storage._isUsingVpn, fieldNumber: 3)
      }
      if _storage._isUsingTor != false {
        try visitor.visitSingularBoolField(value: _storage._isUsingTor, fieldNumber: 4)
      }
      if !_storage._flags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._flags, fieldNumber: 6)
      }
      try { if let v = _storage._userInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._deviceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._geoInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 10)
      }
      if !_storage._supportedChallenges.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._supportedChallenges, fieldNumber: 11)
      }
      if _storage._eventType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._eventType, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Uwproto_AnalysisResponse, rhs: Uwproto_AnalysisResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._isUsingVpn != rhs_storage._isUsingVpn {return false}
        if _storage._isUsingTor != rhs_storage._isUsingTor {return false}
        if _storage._userInfo != rhs_storage._userInfo {return false}
        if _storage._deviceInfo != rhs_storage._deviceInfo {return false}
        if _storage._geoInfo != rhs_storage._geoInfo {return false}
        if _storage._supportedChallenges != rhs_storage._supportedChallenges {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._eventType != rhs_storage._eventType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Uwproto_Flag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Flag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "first_flagged"),
    3: .standard(proto: "most_recently_flagged"),
    4: .standard(proto: "ignored_until"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._firstFlagged) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mostRecentlyFlagged) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ignoredUntil) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._firstFlagged {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mostRecentlyFlagged {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ignoredUntil {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Uwproto_Flag, rhs: Uwproto_Flag) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._firstFlagged != rhs._firstFlagged {return false}
    if lhs._mostRecentlyFlagged != rhs._mostRecentlyFlagged {return false}
    if lhs._ignoredUntil != rhs._ignoredUntil {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Uwproto_UserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "user_email"),
    3: .standard(proto: "user_phone"),
    4: .standard(proto: "user_name"),
    5: .standard(proto: "user_image"),
    6: .standard(proto: "customer_supplied_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userEmail) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userPhone) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userImage) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.customerSuppliedValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.userEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.userEmail, fieldNumber: 2)
    }
    if !self.userPhone.isEmpty {
      try visitor.visitSingularStringField(value: self.userPhone, fieldNumber: 3)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 4)
    }
    if !self.userImage.isEmpty {
      try visitor.visitSingularStringField(value: self.userImage, fieldNumber: 5)
    }
    if !self.customerSuppliedValues.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.customerSuppliedValues, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Uwproto_UserInfo, rhs: Uwproto_UserInfo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.userEmail != rhs.userEmail {return false}
    if lhs.userPhone != rhs.userPhone {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.userImage != rhs.userImage {return false}
    if lhs.customerSuppliedValues != rhs.customerSuppliedValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Uwproto_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .same(proto: "os"),
    3: .standard(proto: "device_class"),
    4: .standard(proto: "device_name"),
    5: .standard(proto: "user_agent"),
    6: .same(proto: "browser"),
    7: .standard(proto: "last_used"),
    8: .standard(proto: "blocked_globally"),
    9: .standard(proto: "blocked_for_this_user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.os) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.deviceClass) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.browser) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastUsed) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.blockedGlobally) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.blockedForThisUser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.os.isEmpty {
      try visitor.visitSingularStringField(value: self.os, fieldNumber: 2)
    }
    if self.deviceClass != .desktop {
      try visitor.visitSingularEnumField(value: self.deviceClass, fieldNumber: 3)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 4)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 5)
    }
    if !self.browser.isEmpty {
      try visitor.visitSingularStringField(value: self.browser, fieldNumber: 6)
    }
    try { if let v = self._lastUsed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.blockedGlobally != false {
      try visitor.visitSingularBoolField(value: self.blockedGlobally, fieldNumber: 8)
    }
    if self.blockedForThisUser != false {
      try visitor.visitSingularBoolField(value: self.blockedForThisUser, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Uwproto_DeviceInfo, rhs: Uwproto_DeviceInfo) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.os != rhs.os {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.browser != rhs.browser {return false}
    if lhs._lastUsed != rhs._lastUsed {return false}
    if lhs.blockedGlobally != rhs.blockedGlobally {return false}
    if lhs.blockedForThisUser != rhs.blockedForThisUser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Uwproto_GeoInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "geo_ip_latlng"),
    2: .standard(proto: "geo_ip_city"),
    3: .standard(proto: "geo_ip_subregion"),
    4: .standard(proto: "geo_ip_region"),
    5: .standard(proto: "last_here"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._geoIpLatlng) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.geoIpCity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.geoIpSubregion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.geoIpRegion) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastHere) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._geoIpLatlng {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.geoIpCity.isEmpty {
      try visitor.visitSingularStringField(value: self.geoIpCity, fieldNumber: 2)
    }
    if !self.geoIpSubregion.isEmpty {
      try visitor.visitSingularStringField(value: self.geoIpSubregion, fieldNumber: 3)
    }
    if !self.geoIpRegion.isEmpty {
      try visitor.visitSingularStringField(value: self.geoIpRegion, fieldNumber: 4)
    }
    try { if let v = self._lastHere {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Uwproto_GeoInfo, rhs: Uwproto_GeoInfo) -> Bool {
    if lhs._geoIpLatlng != rhs._geoIpLatlng {return false}
    if lhs.geoIpCity != rhs.geoIpCity {return false}
    if lhs.geoIpSubregion != rhs.geoIpSubregion {return false}
    if lhs.geoIpRegion != rhs.geoIpRegion {return false}
    if lhs._lastHere != rhs._lastHere {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Uwproto_LatLng: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatLng"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Uwproto_LatLng, rhs: Uwproto_LatLng) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
